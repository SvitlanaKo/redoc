import java.io.File


class Redoc(args: Array<String>) {

    private val usage = """
    Create Markdown doc from Gherkin *.feature files
    USAGE:
    $ kotlinc redoc.kt -include-runtime -d redoc.jar
    $ java -jar redoc.jar <path-to-dir-with-feature-files> <path-to-testplan-md-file>
    """.trimIndent()

    private val beginTxt = "[//]: # (AUTOGENERATED BLOCK BEGIN)"
    private val endTxt = "[//]: # (AUTOGENERATED BLOCK END)"
    private val autogenBlock = Regex("""${beginTxt.escape()}.*${endTxt.escape()}""", RegexOption.DOT_MATCHES_ALL)
    private val at = "@"

    private val lvlFeature = "###"
    private val lvlScenario = "####"

    private val featureDir: File
    private val testplanMd: File

    init {
        if (args.size != 2) {
            die(usage)
        }
        featureDir = File(args[0]).assureValidFeatureDir()
        testplanMd = File(args[1]).assureValidTestplanFile()
    }

    fun update() {
        val newText = composeAutogenBlock()
        updateAutogenBlock(newText)
    }

    private fun composeAutogenBlock(): String {

        val sb = StringBuilder()

        featureDir.featureFiles().sorted().map { feature ->

            val scenarios = feature.scenarioLinesWithLineNumbers()
            sb.append(feature.ghFormatFeature())

            scenarios.forEach {
                sb.append(it.ghFormatScenario(feature))
            }
        }

        return sb.toString()
    }


    private fun updateAutogenBlock(newText: String) {
        val oldText = testplanMd.readText()
        println("updating file: ${testplanMd.canonicalPath}")
        val updated = oldText.replace(autogenBlock, "$beginTxt\n$newText\n$endTxt")
        testplanMd.writeText(updated)
    }

    private fun String.ghFormatScenario(feature: File): String {
        val (scenario, idx) = this.split(at)
        return "\n$lvlScenario [$scenario](${feature.relativeToGitRepoRoot()}#L$idx)\n"
    }

    private fun File.parentDirs(): List<File> {
        val dirs = mutableListOf<File>()
        if (this.isDirectory) {
            dirs.add(this.canonicalFile)
        }
        var dir = this.canonicalFile.parent
        while (dir != null) {
            dirs.add(File(dir))
            dir = File(dir).parent
        }
        return dirs
    }

    private fun File.isGitRepoRoot() = File(this.canonicalPath + "/.git").exists()

    private fun File.relativeToGitRepoRoot(): String {
        val root = this.gitRepoRoot()!!.canonicalPath + "/"
        val pfx = testplanMd.upToGitRoot()
        return this.canonicalPath.replace(root, pfx)
    }


    private fun File.upToGitRoot(): String {
        val root = this.gitRepoRoot()!!.canonicalPath
        var dir = this.parent
        val sb = StringBuilder()//.append("./")
        while (dir != root) {
            sb.append("../")
            dir = File(dir).parent
        }
        return sb.toString()
    }

    private fun File.gitRepoRoot() = this.parentDirs().find { it.isGitRepoRoot() }

    private fun File.ghFormatFeature() = "\n$lvlFeature [${this.parseFeature()}](${this.relativeToGitRepoRoot()})\n"

    private fun File.parseFeature() = this.readLines().find { it.isNotComment() && it.isFeature() }

    private fun File.featureFiles() = this.walk().filter { it.extension == "feature" }.toList()

    private fun File.scenarioLinesWithLineNumbers() = this.readLines().addLineNumbers().filterScenarios()

    private fun List<String>.addLineNumbers() = this.mapIndexed { idx, line -> "${line.trim()}$at${idx + 1}" }

    private fun List<String>.filterScenarios() = this.filter { it.isScenario() && it.isNotComment() }

    private fun String.isNotComment() = !Regex("^\\s*#.*").matches(this)

    private fun String.isScenario() = Regex("^\\s*Scenario:.*").matches(this)

    private fun String.isFeature() = Regex("^\\s*Feature:.*").matches(this)

    private fun String.escape() = Regex.escape(this)


    private fun File.assureValidFeatureDir(): File {
        when {
            !this.exists() -> die("ERROR: feature dir does not exist: $this")
            !this.isDirectory -> die("ERROR: not a directory: $this")
            !this.canRead() -> die("ERROR: cannot read: $this")
            !this.canExecute() -> die("ERROR: cannot list directory: $this")
            this.featureFiles().isEmpty() -> die("ERROR: no *.feature files found in: $this")
            null == this.gitRepoRoot() -> die("ERROR: featureDir must be in git repository: $this")
        }
        return this.canonicalFile
    }

    private fun File.containsAutogenBlock(): Boolean {
        val text = this.readText()
        return text.contains(beginTxt) && text.contains(endTxt)
    }


    private fun File.assureValidTestplanFile(): File {
        if (this.exists()) {
            when {
                !this.isFile -> die("ERROR: not a regular file: $this")
                !this.canRead() -> die("ERROR: cannot read: $this")
                !this.canWrite() -> die("ERROR: cannot write: $this")
                !this.containsAutogenBlock() -> die("ERROR: file contains no autogen block: $this")
            }
        } else {
            if (null == this.gitRepoRoot()) {
                die("ERROR: testplanMd must be in git repository: $this")
            }

            try {
                File(this.parent).mkdirs()
                this.createNewFile()
                this.writeText("$beginTxt\n$endTxt")
            } catch (e: java.io.IOException) {
                die("ERROR: file not exists and cannot be created: $this")
            }
        }
        return this.canonicalFile
    }


    private fun die(message: String, errorCode: Int = 1) {
        System.err.println(message)
        System.exit(errorCode)
    }

}

fun main(args: Array<String>) {
    val redoc = Redoc(args)
    redoc.update()
}